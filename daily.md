## 05/09/2023

Time worked: ~3hrs
Current Task: Implement classic VLM in C++

### Highlights

- Implemented the computation of the connectivity and the panel metrics

### Notes

Connectivity is easy because we are using a structured mesh. We can easily find the vertices of a panel using some arithmetic using the grid size:

```c++
u32 chord_idx = i / surface.nc;
quad[0] = i + chord_idx;
quad[1] = quad[0] + 1;
quad[2] = quad[1] + surface.ns;
quad[3] = quad[0] + surface.ns;
```

For the metrics, I'm following the formulas used in the python VLM code. Say we have a panel composed of the points A, B, C, D (in clockwise). 

The normal is computed as a crossproduct between the diagonal vectors of the quadraliteral.

$$
\vec{n} = \vec{BD} \times \vec{AC}
$$

I'm assuming that the normal is pointing towards the z direction (will be checking when running for first time). 

The area is computed as the average magnitude of two vector crossproducts. 

$$
\text{Area} = 0.5 \cdot \left( ||\vec{AB} \times \vec{AC}|| + || \vec{AC} \times \vec{AD} ||\right)
$$

After a quick look online I found another formula that could work and that is also more computationally efficient. Might be worth to try it out but for the moment I'm sticking to the formula used in the Python code.

$$ 
\text{Area} =  || 0.5 \cdot \left(\vec{AB} \times \vec{AC} + \vec{AC} \times \vec{AD} \right) ||
$$

In the Python code, The collocation point is calculated as the arithmetic average of the points coordinates (euclidean method). I found that odd because in Katz & Plotkin Low Speed Aero book, the collocation point is placed at 3/4 of the local panel chord. I was told by a labmate that it doesnt matter that much.

$$
\text{Collocation} = 0.25 \cdot (A + B + C + D)
$$

### Future thoughts

When writing out the cross products (which are also used in the bio-savart computation), I realized that the memory layout for the points might not be optimal because chordwise points are not coalesced in memory. Need to investigate !

## 06/09/2023

Time worked: ~5hrs
Current Task: Implement classic VLM in C++

### Highlights
- Adopted a new memory layout to store the vertices coordinates.
- Refactored the Mesh class to now incorporate the panels and vertices together. This makes sense because since it's a structured mesh then those two are closely tied together.
- Adopted the usage of a new SoA struct to store 3 arrays (for x, y, and z) so that the definition of the Mesh class is cleaner.

### Notes
The problem about storing the coordinates in span or chord major order is that when computing the bio-savart formula you wont be able to perform coalesced loads and store for edges that are orthogonal to the chosen memory layout. The solution for this is to store the vertex coordinates of each corner (for each panel) in separate arrays (could be just one with offsets but 4 arrays is more ergonomic). This will let us use fully vertical SIMD when filling the LHS matrix ! The downside is that the coordinates are stored in dupplicate. The factor of extra memory that it uses vs a conventional layout is given by the formula:

$$
4\ \cdot\ \left(1-\left(\frac{ns+nc-1}{ns \cdot nc}\right)\right)
$$

If say $nc=ns$ then the single variable equation converges to 4 when x tends toward infinity. This means that we are using ~4x more memory. This should not be a huge issue as much of the memory constraints come from the storage of the dense LHS matrix.

### Future thoughts

Started loosely thinking about parallelization of the matrix assembly. CPU might get bandwidth-starved if we parallellized for computing the influence of different collocation points at the same time. The other option would be to compute the influences at a single collocation point in parallel. This loop exposes less parallelism but will incur less memory traffic I think. However this would have to be implemented as a parallel reduction ! To be tested in the future.

## 07/09/2023

Time worked: ~4hrs
Current Task: Implement classic VLM in C++

### Highlights

- Finished integrating the new memory layout in all the functions
- Added computation of the system LHS: the influence matrix

### Notes

The new memory layout caused some issues and I had to debug some array indexing errors. Turns out it's a bit complicated to fill those 4 vectors in a sane way because the vertices are laid out in a spanwise manner.

The influence matrix routine was pretty simple to write with this new layout since each vertex of each panel is easily accessible with the same index. I compared the influence matrix obtained with my code with the python one and there is some differences. I assume this is due to the fact that although both meshes contain the same number of panels, the vertices are not exactly at the same place. Will have to test my code with the mesh generated by the python code instead of my own that was generated with Pointwise. 

### Future thoughts

While writing the influence matrix routine, I noticed that since inner vortex lines share 2 panels, the influence is computed 2 times. After some vector algebra on the bio-savart formula, I found that the influence is multiplied by -1 when calculated on the neighbor panel because the vortex direction changes according to which panel we consider the vortex line to be coming from. Basically there might be an optimisation here, where instead of looping on the panels and then on the vortex lines, we could invert the loop order and effectively reduce the number of computations by 2 (asymptotically). However, in order to carry this out in an efficient manner, we would need a new memory layout and a more complex computation "scheme" to handle inner lines (that influence twice) and outer lines (that only influence their master panel). 

## 08/09/2023

Time worked: ~5hrs
Current Task: Implement classic VLM in C++

### Highlights

- Added Plot3D structured file format support
- Validated the influence matrix with the same mesh used by python code.
- Implemented RHS computation
- Implemented the system solver (with Eigen's BiCGSTAB)

### Notes

When writing the function to export the mesh generated and used by the Python code, in order to check if it worked correctly I tried reading it in Pointwise. That's when I found out that Pointwise doesn't support importing from GridPro structured file format (only exporting) ! I decided to go with the Plot3D ASCII structured file format because it was support for both import and export. 

Influence matrix coefficients were compared to the python code and came out to be exactly the same. I also fixed a small bug where the last wake panel was not taken into consideration.

RHS implementation was straightforward.

Trying Eigen for the first time and it was pretty simple to use ! I mapped my matrix and vector buffers onto an Eigen matrix object and then called the solver.

### Future thoughts

I'm not sure how optimised Eigen's solvers are for dense matrices and if everything is parallelized. If I have time, I'd love to write my own BiCGSTAB solver and see if I can go faster. 

## 12/09/2023
Time worked: 7hr
Current Task: Implement classic VLM in C++

### Highlights

- Added the computation of CL, CM and CD coefficients

### Notes
### Future thoughts

## XX/XX/XXXX
Time worked: 
Current Task:
### Highlights
### Notes
### Future thoughts
